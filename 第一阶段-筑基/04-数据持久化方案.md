# 04. æ•°æ®æŒä¹…åŒ–æ–¹æ¡ˆ

## ğŸ“š å­¦ä¹ ç›®æ ‡

- ç†è§£ Chrome Storage API çš„ä¸‰ç§å­˜å‚¨ç±»å‹
- å°è£…ç±»ä¼¼ Pinia/Redux çš„çŠ¶æ€ç®¡ç†
- æŒæ¡å­˜å‚¨é…é¢å’Œæ€§èƒ½ä¼˜åŒ–
- å®ç°æ•°æ®åŒæ­¥å’Œè¿ç§»ç­–ç•¥

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. Chrome Storage API æ¦‚è§ˆ

Chrome Extension æä¾›ä¸‰ç§å­˜å‚¨ç±»å‹ï¼š

| ç±»å‹ | ä½œç”¨åŸŸ | é…é¢ | åŒæ­¥ | ç”¨é€” |
|------|--------|------|------|------|
| `local` | æœ¬åœ°è®¾å¤‡ | ~10MB | âŒ | ç”¨æˆ·è®¾ç½®ã€ç¼“å­˜æ•°æ® |
| `sync` | è·¨è®¾å¤‡åŒæ­¥ | ~100KB | âœ… | ç”¨æˆ·åå¥½ã€å°é‡é…ç½® |
| `session` | ä¼šè¯çº§ | å†…å­˜é™åˆ¶ | âŒ | ä¸´æ—¶æ•°æ®ã€è¿è¡Œæ—¶çŠ¶æ€ |

### 2. Storage å°è£…è®¾è®¡

#### ç±»å‹å®šä¹‰

```typescript
// src/shared/types/storage.ts
export type StorageArea = 'local' | 'sync' | 'session';

export interface StorageOptions {
  area?: StorageArea;
  defaultValue?: any;
  serializer?: {
    serialize: (value: any) => any;
    deserialize: (value: any) => any;
  };
}

export interface StorageChange<T = any> {
  oldValue?: T;
  newValue?: T;
}
```

#### åŸºç¡€ Storage ç±»

```typescript
// src/shared/utils/storage.ts
import { StorageArea, StorageOptions, StorageChange } from '@/shared/types/storage';

export class Storage {
  private area: chrome.storage.StorageArea;

  constructor(area: StorageArea = 'local') {
    this.area = chrome.storage[area];
  }

  async get<T = any>(key: string, options?: StorageOptions): Promise<T | null> {
    try {
      const result = await this.area.get(key);
      const value = result[key];
      
      if (value === undefined) {
        return options?.defaultValue ?? null;
      }

      if (options?.serializer) {
        return options.serializer.deserialize(value);
      }

      return value as T;
    } catch (error) {
      console.error(`Storage get error for key "${key}":`, error);
      return options?.defaultValue ?? null;
    }
  }

  async set<T = any>(key: string, value: T, options?: StorageOptions): Promise<void> {
    try {
      let serializedValue = value;
      
      if (options?.serializer) {
        serializedValue = options.serializer.serialize(value);
      }

      await this.area.set({ [key]: serializedValue });
    } catch (error) {
      console.error(`Storage set error for key "${key}":`, error);
      throw error;
    }
  }

  async remove(key: string): Promise<void> {
    await this.area.remove(key);
  }

  async clear(): Promise<void> {
    await this.area.clear();
  }

  async getAll(): Promise<Record<string, any>> {
    return await this.area.get(null);
  }

  onChange(callback: (changes: Record<string, StorageChange>) => void) {
    chrome.storage.onChanged.addListener((changes, areaName) => {
      if (areaName === this.areaName) {
        callback(changes);
      }
    });
  }

  private get areaName(): StorageArea {
    if (this.area === chrome.storage.local) return 'local';
    if (this.area === chrome.storage.sync) return 'sync';
    return 'session';
  }
}
```

### 3. çŠ¶æ€ç®¡ç†å°è£…ï¼ˆç±»ä¼¼ Piniaï¼‰

#### Store åŸºç±»

```typescript
// src/shared/stores/baseStore.ts
import { Storage } from '@/shared/utils/storage';
import { StorageArea } from '@/shared/types/storage';

export abstract class BaseStore<T extends Record<string, any>> {
  protected storage: Storage;
  protected state: T;
  private listeners: Set<(state: T) => void> = new Set();

  constructor(
    protected storeName: string,
    protected initialState: T,
    area: StorageArea = 'local'
  ) {
    this.storage = new Storage(area);
    this.state = { ...initialState };
    this.init();
  }

  private async init() {
    // ä»å­˜å‚¨åŠ è½½çŠ¶æ€
    const savedState = await this.storage.get<T>(this.storeName);
    if (savedState) {
      this.state = { ...this.initialState, ...savedState };
    }

    // ç›‘å¬å­˜å‚¨å˜åŒ–
    this.storage.onChange((changes) => {
      if (changes[this.storeName]) {
        const newState = changes[this.storeName].newValue as T;
        if (newState) {
          this.state = newState;
          this.notify();
        }
      }
    });
  }

  getState(): T {
    return { ...this.state };
  }

  setState(updates: Partial<T>): void {
    this.state = { ...this.state, ...updates };
    this.persist();
    this.notify();
  }

  reset(): void {
    this.state = { ...this.initialState };
    this.persist();
    this.notify();
  }

  subscribe(listener: (state: T) => void): () => void {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notify(): void {
    this.listeners.forEach(listener => listener(this.getState()));
  }

  private async persist(): Promise<void> {
    await this.storage.set(this.storeName, this.state);
  }
}
```

#### ä½¿ç”¨ç¤ºä¾‹ï¼šç”¨æˆ·è®¾ç½® Store

```typescript
// src/shared/stores/settingsStore.ts
import { BaseStore } from './baseStore';

interface SettingsState {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  notifications: boolean;
  autoSync: boolean;
}

class SettingsStore extends BaseStore<SettingsState> {
  constructor() {
    super(
      'settings',
      {
        theme: 'auto',
        language: 'zh-CN',
        notifications: true,
        autoSync: false,
      },
      'sync' // ä½¿ç”¨ sync è·¨è®¾å¤‡åŒæ­¥
    );
  }

  setTheme(theme: SettingsState['theme']) {
    this.setState({ theme });
  }

  setLanguage(language: string) {
    this.setState({ language });
  }

  toggleNotifications() {
    this.setState({ notifications: !this.state.notifications });
  }
}

export const settingsStore = new SettingsStore();
```

#### åœ¨ Vue ç»„ä»¶ä¸­ä½¿ç”¨

```vue
<!-- src/popup/components/Settings.vue -->
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { settingsStore } from '@/shared/stores/settingsStore';

const state = ref(settingsStore.getState());
let unsubscribe: (() => void) | null = null;

onMounted(() => {
  unsubscribe = settingsStore.subscribe((newState) => {
    state.value = newState;
  });
});

onUnmounted(() => {
  unsubscribe?.();
});

function handleThemeChange(theme: 'light' | 'dark' | 'auto') {
  settingsStore.setTheme(theme);
}
</script>

<template>
  <div>
    <select :value="state.theme" @change="handleThemeChange($event.target.value)">
      <option value="light">æµ…è‰²</option>
      <option value="dark">æ·±è‰²</option>
      <option value="auto">è‡ªåŠ¨</option>
    </select>
  </div>
</template>
```

### 4. é«˜çº§åŠŸèƒ½

#### åºåˆ—åŒ–å™¨ï¼ˆå¤„ç†å¤æ‚æ•°æ®ç±»å‹ï¼‰

```typescript
// src/shared/utils/serializers.ts
export const serializers = {
  date: {
    serialize: (value: Date) => value.toISOString(),
    deserialize: (value: string) => new Date(value),
  },
  
  map: {
    serialize: (value: Map<any, any>) => Array.from(value.entries()),
    deserialize: (value: [any, any][]) => new Map(value),
  },
  
  set: {
    serialize: (value: Set<any>) => Array.from(value),
    deserialize: (value: any[]) => new Set(value),
  },
};

// ä½¿ç”¨
const storage = new Storage('local');
await storage.set('dates', [new Date()], {
  serializer: {
    serialize: (dates: Date[]) => dates.map(d => d.toISOString()),
    deserialize: (strings: string[]) => strings.map(s => new Date(s)),
  }
});
```

#### å­˜å‚¨é…é¢ç®¡ç†

```typescript
// src/shared/utils/storageQuota.ts
export class StorageQuota {
  static async getUsage(area: StorageArea = 'local'): Promise<{
    used: number;
    quota: number;
    percentage: number;
  }> {
    const storage = chrome.storage[area];
    const usage = await storage.getBytesInUse(null);
    
    const quota = area === 'sync' ? 102400 : 10485760; // 100KB or 10MB
    
    return {
      used: usage,
      quota,
      percentage: (usage / quota) * 100,
    };
  }

  static async checkAndClean(area: StorageArea = 'local', threshold = 0.8) {
    const usage = await this.getUsage(area);
    
    if (usage.percentage > threshold * 100) {
      // æ¸…ç†æ—§æ•°æ®
      const allData = await chrome.storage[area].get(null);
      const sortedKeys = Object.keys(allData).sort((a, b) => {
        // æŒ‰æœ€åè®¿é—®æ—¶é—´æ’åºï¼ˆéœ€è¦è‡ªå·±ç»´æŠ¤ï¼‰
        return 0;
      });
      
      // åˆ é™¤æœ€æ—§çš„ 20% æ•°æ®
      const keysToRemove = sortedKeys.slice(0, Math.floor(sortedKeys.length * 0.2));
      await chrome.storage[area].remove(keysToRemove);
    }
  }
}
```

#### æ•°æ®è¿ç§»

```typescript
// src/shared/utils/migration.ts
interface Migration {
  version: number;
  up: (data: any) => Promise<any>;
  down?: (data: any) => Promise<any>;
}

export class StorageMigration {
  private migrations: Migration[] = [];
  private currentVersion: number = 1;

  addMigration(migration: Migration) {
    this.migrations.push(migration);
    this.migrations.sort((a, b) => a.version - b.version);
  }

  async migrate(storage: Storage, key: string) {
    const versionKey = `${key}_version`;
    const currentVersion = await storage.get<number>(versionKey) || 1;
    
    const migrationsToRun = this.migrations.filter(m => m.version > currentVersion);
    
    for (const migration of migrationsToRun) {
      const data = await storage.get(key);
      const migratedData = await migration.up(data);
      await storage.set(key, migratedData);
      await storage.set(versionKey, migration.version);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const migration = new StorageMigration();
migration.addMigration({
  version: 2,
  up: async (data) => {
    // è¿ç§»é€»è¾‘ï¼šæ·»åŠ æ–°å­—æ®µ
    return {
      ...data,
      newField: 'defaultValue',
    };
  },
});
```

### 5. æ€§èƒ½ä¼˜åŒ–

#### æ‰¹é‡æ“ä½œ

```typescript
// src/shared/utils/storage.ts (æ‰©å±•)
async setBatch(items: Record<string, any>): Promise<void> {
  await this.area.set(items);
}

async getBatch(keys: string[]): Promise<Record<string, any>> {
  return await this.area.get(keys);
}

async removeBatch(keys: string[]): Promise<void> {
  await this.area.remove(keys);
}
```

#### é˜²æŠ–å†™å…¥

```typescript
// src/shared/utils/debouncedStorage.ts
import { Storage } from './storage';

export class DebouncedStorage extends Storage {
  private debounceTimers = new Map<string, NodeJS.Timeout>();
  private debounceDelay = 300;

  async set<T = any>(key: string, value: T, options?: StorageOptions): Promise<void> {
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    const existingTimer = this.debounceTimers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    // è®¾ç½®æ–°çš„å®šæ—¶å™¨
    const timer = setTimeout(async () => {
      await super.set(key, value, options);
      this.debounceTimers.delete(key);
    }, this.debounceDelay);

    this.debounceTimers.set(key, timer);
  }

  async flush(): Promise<void> {
    // ç«‹å³æ‰§è¡Œæ‰€æœ‰å¾…å¤„ç†çš„å†™å…¥
    const timers = Array.from(this.debounceTimers.values());
    this.debounceTimers.clear();
    
    timers.forEach(timer => clearTimeout(timer));
    // éœ€è¦å®ç°ä¸€ä¸ªæœºåˆ¶æ¥è·å–å¾…å†™å…¥çš„æ•°æ®
  }
}
```

## ğŸ› ï¸ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1ï¼šå®ç°ç¼“å­˜ Store

```typescript
// src/shared/stores/cacheStore.ts
interface CacheItem<T> {
  data: T;
  timestamp: number;
  ttl: number; // ç”Ÿå­˜æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
}

class CacheStore extends BaseStore<Record<string, CacheItem<any>>> {
  constructor() {
    super('cache', {});
  }

  set<T>(key: string, data: T, ttl = 3600000): void {
    this.setState({
      [key]: {
        data,
        timestamp: Date.now(),
        ttl,
      },
    });
  }

  get<T>(key: string): T | null {
    const item = this.state[key] as CacheItem<T> | undefined;
    
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      // è¿‡æœŸï¼Œåˆ é™¤
      const newState = { ...this.state };
      delete newState[key];
      this.setState(newState);
      return null;
    }
    
    return item.data;
  }

  clearExpired(): void {
    const now = Date.now();
    const newState = { ...this.state };
    
    Object.keys(newState).forEach(key => {
      const item = newState[key];
      if (now - item.timestamp > item.ttl) {
        delete newState[key];
      }
    });
    
    this.setState(newState);
  }
}
```

## ğŸ“ æ€»ç»“

- æ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©åˆé€‚çš„å­˜å‚¨ç±»å‹ï¼ˆlocal/sync/sessionï¼‰
- å°è£… Store æ¨¡å¼å®ç°çŠ¶æ€ç®¡ç†ï¼Œç±»ä¼¼ Pinia
- æ³¨æ„å­˜å‚¨é…é¢ï¼Œå®ç°æ¸…ç†å’Œè¿ç§»ç­–ç•¥
- ä½¿ç”¨æ‰¹é‡æ“ä½œå’Œé˜²æŠ–ä¼˜åŒ–æ€§èƒ½

## ğŸ”— æ‰©å±•é˜…è¯»

- [Chrome Storage API](https://developer.chrome.com/docs/extensions/reference/storage/)
- [å­˜å‚¨é…é¢é™åˆ¶](https://developer.chrome.com/docs/extensions/reference/storage/#property-sync)

