# 10. æ¨¡æ‹ŸçœŸäººçš„è‰ºæœ¯ï¼šè‡ªåŠ¨åŒ–ä¸åçˆ¬

## ğŸ“š å­¦ä¹ ç›®æ ‡

- ç†è§£æµè§ˆå™¨è‡ªåŠ¨åŒ–æ£€æµ‹æœºåˆ¶
- æŒæ¡ç”ŸæˆçœŸå®ç”¨æˆ·äº‹ä»¶çš„æ–¹æ³•
- å­¦ä¹ ä½¿ç”¨ CDP (Chrome DevTools Protocol)
- å®ç°åçˆ¬è™«å¯¹æŠ—æŠ€æœ¯

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. æµè§ˆå™¨è‡ªåŠ¨åŒ–æ£€æµ‹

ç½‘ç«™é€šè¿‡å¤šç§æ–¹å¼æ£€æµ‹è‡ªåŠ¨åŒ–å·¥å…·ï¼š

#### æ£€æµ‹æ–¹æ³•

1. **äº‹ä»¶æ£€æµ‹**ï¼š`isTrusted` å±æ€§
2. **è¡Œä¸ºæ¨¡å¼**ï¼šé¼ æ ‡è½¨è¿¹ã€ç‚¹å‡»é€Ÿåº¦
3. **æµè§ˆå™¨æŒ‡çº¹**ï¼šWebDriver ç‰¹å¾ã€æ’ä»¶ä¿¡æ¯
4. **JavaScript ç¯å¢ƒ**ï¼š`navigator.webdriver`ã€`window.chrome`
5. **æ—¶é—´æ¨¡å¼**ï¼šæ“ä½œé—´éš”è¿‡äºè§„å¾‹

### 2. ç”ŸæˆçœŸå®äº‹ä»¶

#### é—®é¢˜ï¼šä¸ºä»€ä¹ˆ `element.click()` æ— æ•ˆï¼Ÿ

```javascript
// âŒ è¿™ç§æ–¹å¼ä¼šè¢«æ£€æµ‹
element.click(); // isTrusted: false
```

#### è§£å†³æ–¹æ¡ˆä¸€ï¼šä½¿ç”¨çœŸå®äº‹ä»¶

```typescript
// src/content/utils/realEvents.ts
export class RealEventGenerator {
  // ç”ŸæˆçœŸå®çš„ç‚¹å‡»äº‹ä»¶
  static click(element: HTMLElement, options?: MouseEventInit): void {
    const event = new MouseEvent('click', {
      bubbles: true,
      cancelable: true,
      view: window,
      ...options,
    });
    
    element.dispatchEvent(event);
  }
  
  // ç”ŸæˆçœŸå®çš„é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆå¸¦è½¨è¿¹ï¼‰
  static mouseMove(
    from: { x: number; y: number },
    to: { x: number; y: number },
    element: HTMLElement,
    duration = 200
  ): void {
    const steps = 20;
    const stepDuration = duration / steps;
    const deltaX = (to.x - from.x) / steps;
    const deltaY = (to.y - from.y) / steps;
    
    let currentStep = 0;
    const interval = setInterval(() => {
      currentStep++;
      const x = from.x + deltaX * currentStep;
      const y = from.y + deltaY * currentStep;
      
      const event = new MouseEvent('mousemove', {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: x,
        clientY: y,
      });
      
      element.dispatchEvent(event);
      
      if (currentStep >= steps) {
        clearInterval(interval);
      }
    }, stepDuration);
  }
  
  // ç”ŸæˆçœŸå®çš„é”®ç›˜äº‹ä»¶
  static type(element: HTMLElement, text: string, delay = 50): Promise<void> {
    return new Promise((resolve) => {
      let index = 0;
      
      const typeChar = () => {
        if (index < text.length) {
          const char = text[index];
          
          // è¾“å…¥å­—ç¬¦
          const inputEvent = new InputEvent('input', {
            bubbles: true,
            cancelable: true,
            data: char,
          });
          
          const keydownEvent = new KeyboardEvent('keydown', {
            bubbles: true,
            cancelable: true,
            key: char,
            code: `Key${char.toUpperCase()}`,
          });
          
          const keyupEvent = new KeyboardEvent('keyup', {
            bubbles: true,
            cancelable: true,
            key: char,
            code: `Key${char.toUpperCase()}`,
          });
          
          element.dispatchEvent(keydownEvent);
          element.dispatchEvent(inputEvent);
          element.dispatchEvent(keyupEvent);
          
          // æ›´æ–°å…ƒç´ å€¼ï¼ˆå¯¹äº input å…ƒç´ ï¼‰
          if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
            element.value += char;
          }
          
          index++;
          setTimeout(typeChar, delay + Math.random() * 20); // éšæœºå»¶è¿Ÿ
        } else {
          resolve();
        }
      };
      
      element.focus();
      typeChar();
    });
  }
  
  // ç”Ÿæˆäººç±»åŒ–çš„ç‚¹å‡»ï¼ˆå¸¦ç§»åŠ¨è½¨è¿¹ï¼‰
  static humanClick(element: HTMLElement): Promise<void> {
    return new Promise((resolve) => {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // éšæœºèµ·å§‹ä½ç½®ï¼ˆç¨å¾®åç§»ï¼‰
      const startX = centerX + (Math.random() - 0.5) * 50;
      const startY = centerY + (Math.random() - 0.5) * 50;
      
      // ç§»åŠ¨é¼ æ ‡åˆ°å…ƒç´ 
      this.mouseMove(
        { x: startX, y: startY },
        { x: centerX, y: centerY },
        document.body,
        100 + Math.random() * 100
      );
      
      // å»¶è¿Ÿåç‚¹å‡»
      setTimeout(() => {
        this.click(element, {
          clientX: centerX,
          clientY: centerY,
        });
        resolve();
      }, 150 + Math.random() * 100);
    });
  }
}
```

### 3. ä½¿ç”¨ CDP (Chrome DevTools Protocol)

CDP å¯ä»¥å‘é€ç‰©ç†çº§çš„é¼ æ ‡é”®ç›˜æŒ‡ä»¤ï¼Œæ›´éš¾è¢«æ£€æµ‹ã€‚

#### manifest.json é…ç½®

```json
{
  "permissions": [
    "debugger"
  ]
}
```

#### CDP å®ç°

```typescript
// src/background/cdpController.ts
export class CDPController {
  private tabId: number | null = null;
  
  async attach(tabId: number): Promise<void> {
    this.tabId = tabId;
    await chrome.debugger.attach({ tabId }, '1.0');
  }
  
  async detach(): Promise<void> {
    if (this.tabId !== null) {
      await chrome.debugger.detach({ tabId: this.tabId });
      this.tabId = null;
    }
  }
  
  // å‘é€ CDP å‘½ä»¤
  private async sendCommand(method: string, params?: any): Promise<any> {
    if (this.tabId === null) {
      throw new Error('CDP not attached');
    }
    
    return new Promise((resolve, reject) => {
      chrome.debugger.sendCommand(
        { tabId: this.tabId! },
        method,
        params,
        (result) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(result);
          }
        }
      );
    });
  }
  
  // é¼ æ ‡ç‚¹å‡»
  async mouseClick(x: number, y: number, button: 'left' | 'right' | 'middle' = 'left'): Promise<void> {
    const buttonMap = { left: 'left', right: 'right', middle: 'middle' };
    
    // æŒ‰ä¸‹
    await this.sendCommand('Input.dispatchMouseEvent', {
      type: 'mousePressed',
      x,
      y,
      button: buttonMap[button],
      clickCount: 1,
    });
    
    // é‡Šæ”¾
    await this.sendCommand('Input.dispatchMouseEvent', {
      type: 'mouseReleased',
      x,
      y,
      button: buttonMap[button],
      clickCount: 1,
    });
  }
  
  // é¼ æ ‡ç§»åŠ¨ï¼ˆå¸¦è½¨è¿¹ï¼‰
  async mouseMove(
    from: { x: number; y: number },
    to: { x: number; y: number },
    steps = 20
  ): Promise<void> {
    const deltaX = (to.x - from.x) / steps;
    const deltaY = (to.y - from.y) / steps;
    
    for (let i = 0; i <= steps; i++) {
      const x = from.x + deltaX * i;
      const y = from.y + deltaY * i;
      
      await this.sendCommand('Input.dispatchMouseEvent', {
        type: 'mouseMoved',
        x,
        y,
      });
      
      // éšæœºå»¶è¿Ÿï¼ˆæ¨¡æ‹Ÿäººç±»ï¼‰
      await this.sleep(5 + Math.random() * 5);
    }
  }
  
  // é”®ç›˜è¾“å…¥
  async keyboardType(text: string, delay = 50): Promise<void> {
    for (const char of text) {
      await this.sendCommand('Input.dispatchKeyEvent', {
        type: 'char',
        text: char,
      });
      
      await this.sleep(delay + Math.random() * 20);
    }
  }
  
  // é”®ç›˜æŒ‰é”®
  async keyboardPress(key: string): Promise<void> {
    await this.sendCommand('Input.dispatchKeyEvent', {
      type: 'keyDown',
      windowsVirtualKeyCode: this.getKeyCode(key),
    });
    
    await this.sendCommand('Input.dispatchKeyEvent', {
      type: 'keyUp',
      windowsVirtualKeyCode: this.getKeyCode(key),
    });
  }
  
  private getKeyCode(key: string): number {
    const keyMap: Record<string, number> = {
      Enter: 13,
      Tab: 9,
      Escape: 27,
      Backspace: 8,
      // æ›´å¤šæŒ‰é”®...
    };
    return keyMap[key] || key.charCodeAt(0);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // æˆªå›¾
  async screenshot(format: 'png' | 'jpeg' = 'png', quality = 90): Promise<string> {
    const result = await this.sendCommand('Page.captureScreenshot', {
      format,
      quality: format === 'jpeg' ? quality : undefined,
    });
    return result.data;
  }
  
  // è·å–å…ƒç´ ä½ç½®å¹¶ç‚¹å‡»
  async clickElement(selector: string): Promise<void> {
    // é€šè¿‡ Content Script è·å–å…ƒç´ ä½ç½®
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    const result = await chrome.scripting.executeScript({
      target: { tabId: tab.id! },
      func: (sel: string) => {
        const element = document.querySelector(sel) as HTMLElement;
        if (element) {
          const rect = element.getBoundingClientRect();
          return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
          };
        }
        return null;
      },
      args: [selector],
    });
    
    if (result[0].result) {
      const { x, y } = result[0].result;
      await this.mouseClick(x, y);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const cdp = new CDPController();
const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
await cdp.attach(tab.id!);
await cdp.clickElement('.submit-button');
await cdp.detach();
```

### 4. äººç±»è¡Œä¸ºæ¨¡æ‹Ÿ

#### éšæœºå»¶è¿Ÿ

```typescript
// src/content/utils/humanBehavior.ts
export class HumanBehavior {
  // äººç±»åŒ–çš„å»¶è¿Ÿï¼ˆéšæœºï¼‰
  static async randomDelay(min: number, max: number): Promise<void> {
    const delay = min + Math.random() * (max - min);
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  // äººç±»åŒ–çš„é¼ æ ‡ç§»åŠ¨è½¨è¿¹ï¼ˆè´å¡å°”æ›²çº¿ï¼‰
  static generateBezierPath(
    from: { x: number; y: number },
    to: { x: number; y: number }
  ): Array<{ x: number; y: number }> {
    // æ§åˆ¶ç‚¹ï¼ˆéšæœºåç§»ï¼‰
    const cp1 = {
      x: from.x + (to.x - from.x) * 0.25 + (Math.random() - 0.5) * 50,
      y: from.y + (to.y - from.y) * 0.25 + (Math.random() - 0.5) * 50,
    };
    
    const cp2 = {
      x: from.x + (to.x - from.x) * 0.75 + (Math.random() - 0.5) * 50,
      y: from.y + (to.y - from.y) * 0.75 + (Math.random() - 0.5) * 50,
    };
    
    const points: Array<{ x: number; y: number }> = [];
    const steps = 50;
    
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = this.bezier(t, from.x, cp1.x, cp2.x, to.x);
      const y = this.bezier(t, from.y, cp1.y, cp2.y, to.y);
      points.push({ x, y });
    }
    
    return points;
  }
  
  private static bezier(t: number, p0: number, p1: number, p2: number, p3: number): number {
    const u = 1 - t;
    return u * u * u * p0 + 3 * u * u * t * p1 + 3 * u * t * t * p2 + t * t * t * p3;
  }
  
  // æ¨¡æ‹Ÿé˜…è¯»æ—¶é—´ï¼ˆåŸºäºæ–‡æœ¬é•¿åº¦ï¼‰
  static calculateReadingTime(text: string, wordsPerMinute = 200): number {
    const words = text.split(/\s+/).length;
    const minutes = words / wordsPerMinute;
    return minutes * 60 * 1000; // è½¬ä¸ºæ¯«ç§’
  }
  
  // æ¨¡æ‹Ÿæ»šåŠ¨è¡Œä¸º
  static async humanScroll(
    element: HTMLElement,
    targetScrollTop: number,
    duration = 1000
  ): Promise<void> {
    const startScrollTop = element.scrollTop;
    const distance = targetScrollTop - startScrollTop;
    const steps = 30;
    const stepDistance = distance / steps;
    const stepDuration = duration / steps;
    
    for (let i = 0; i <= steps; i++) {
      const scrollTop = startScrollTop + stepDistance * i;
      element.scrollTop = scrollTop;
      
      // æ·»åŠ éšæœºæŠ–åŠ¨
      await this.randomDelay(stepDuration * 0.8, stepDuration * 1.2);
    }
  }
}
```

### 5. åæ£€æµ‹æŠ€æœ¯

#### éšè— WebDriver ç‰¹å¾

```typescript
// src/content/inject/stealth.ts
export class StealthMode {
  static enable() {
    // 1. éšè— webdriver å±æ€§
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
    });
    
    // 2. æ¨¡æ‹ŸçœŸå®çš„ Chrome å¯¹è±¡
    (window as any).chrome = {
      runtime: {},
    };
    
    // 3. ä¿®æ”¹ plugins å±æ€§
    Object.defineProperty(navigator, 'plugins', {
      get: () => [1, 2, 3, 4, 5], // æ¨¡æ‹Ÿæ’ä»¶
    });
    
    // 4. ä¿®æ”¹ languages å±æ€§
    Object.defineProperty(navigator, 'languages', {
      get: () => ['zh-CN', 'zh', 'en'],
    });
    
    // 5. ä¿®æ”¹ permissions
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters: any) => (
      parameters.name === 'notifications' ?
        Promise.resolve({ state: Notification.permission as PermissionState }) :
        originalQuery(parameters)
    );
    
    // 6. è¦†ç›– toString æ–¹æ³•
    const getParameter = WebGLRenderingContext.prototype.getParameter;
    WebGLRenderingContext.prototype.getParameter = function(parameter: number) {
      if (parameter === 37445) {
        return 'Intel Inc.';
      }
      if (parameter === 37446) {
        return 'Intel Iris OpenGL Engine';
      }
      return getParameter.call(this, parameter);
    };
  }
}
```

#### éªŒè¯ç å¯¹æŠ—æ€è·¯

```typescript
// src/content/utils/captchaSolver.ts
export class CaptchaSolver {
  // æ»‘å—éªŒè¯ç ï¼ˆè·å–å›¾ç‰‡åæ ‡ï¼‰
  static async solveSliderCaptcha(
    backgroundImage: HTMLImageElement,
    sliderImage: HTMLImageElement
  ): Promise<number> {
    // ä½¿ç”¨ Canvas åˆ†æå›¾ç‰‡
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    
    canvas.width = backgroundImage.width;
    canvas.height = backgroundImage.height;
    
    ctx.drawImage(backgroundImage, 0, 0);
    const bgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(sliderImage, 0, 0);
    const sliderData = ctx.getImageData(0, 0, sliderImage.width, sliderImage.height);
    
    // ç®€å•çš„æ¨¡æ¿åŒ¹é…ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•ï¼‰
    let bestMatch = 0;
    let bestScore = 0;
    
    for (let x = 0; x < bgData.width - sliderData.width; x++) {
      let score = 0;
      for (let y = 0; y < bgData.height - sliderData.height; y++) {
        // è®¡ç®—ç›¸ä¼¼åº¦
        for (let i = 0; i < sliderData.data.length; i += 4) {
          const bgIndex = ((y + Math.floor(i / 4 / sliderData.width)) * bgData.width + 
                           (x + (i / 4 % sliderData.width))) * 4;
          
          const diff = Math.abs(
            bgData.data[bgIndex] - sliderData.data[i] +
            bgData.data[bgIndex + 1] - sliderData.data[i + 1] +
            bgData.data[bgIndex + 2] - sliderData.data[i + 2]
          );
          
          score += 255 * 3 - diff;
        }
      }
      
      if (score > bestScore) {
        bestScore = score;
        bestMatch = x;
      }
    }
    
    return bestMatch;
  }
  
  // æ¨¡æ‹Ÿäººç±»æ‹–åŠ¨è½¨è¿¹
  static generateDragPath(
    from: { x: number; y: number },
    to: { x: number; y: number }
  ): Array<{ x: number; y: number; t: number }> {
    const path = HumanBehavior.generateBezierPath(from, to);
    const totalTime = 1000 + Math.random() * 500; // 1-1.5ç§’
    
    return path.map((point, index) => ({
      ...point,
      t: (index / path.length) * totalTime,
    }));
  }
}
```

## ğŸ› ï¸ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1ï¼šè‡ªåŠ¨åŒ–ç™»å½•è„šæœ¬

åˆ›å»ºä¸€ä¸ªè‡ªåŠ¨åŒ–ç™»å½•è„šæœ¬ï¼Œæ¨¡æ‹ŸçœŸå®ç”¨æˆ·è¡Œä¸ºï¼š

```typescript
// src/content/automation/login.ts
export class AutoLogin {
  async login(username: string, password: string) {
    // 1. éšæœºå»¶è¿Ÿ
    await HumanBehavior.randomDelay(500, 1500);
    
    // 2. æ‰¾åˆ°ç”¨æˆ·åè¾“å…¥æ¡†
    const usernameInput = document.querySelector('input[type="text"]') as HTMLInputElement;
    await RealEventGenerator.humanClick(usernameInput);
    await HumanBehavior.randomDelay(200, 500);
    
    // 3. è¾“å…¥ç”¨æˆ·åï¼ˆæ¨¡æ‹Ÿæ‰“å­—ï¼‰
    await RealEventGenerator.type(usernameInput, username);
    await HumanBehavior.randomDelay(300, 800);
    
    // 4. æ‰¾åˆ°å¯†ç è¾“å…¥æ¡†
    const passwordInput = document.querySelector('input[type="password"]') as HTMLInputElement;
    await RealEventGenerator.humanClick(passwordInput);
    await HumanBehavior.randomDelay(200, 500);
    
    // 5. è¾“å…¥å¯†ç 
    await RealEventGenerator.type(passwordInput, password);
    await HumanBehavior.randomDelay(500, 1000);
    
    // 6. ç‚¹å‡»ç™»å½•æŒ‰é’®
    const loginButton = document.querySelector('button[type="submit"]') as HTMLButtonElement;
    await RealEventGenerator.humanClick(loginButton);
  }
}
```

## ğŸ“ æ€»ç»“

- çœŸå®äº‹ä»¶ï¼ˆ`isTrusted: true`ï¼‰æ¯”ç¼–ç¨‹äº‹ä»¶æ›´éš¾æ£€æµ‹
- CDP å¯ä»¥å‘é€ç‰©ç†çº§æŒ‡ä»¤ï¼Œæ˜¯æœ€éš¾æ£€æµ‹çš„æ–¹å¼
- äººç±»è¡Œä¸ºæ¨¡æ‹Ÿï¼ˆéšæœºå»¶è¿Ÿã€è½¨è¿¹ï¼‰æå‡çœŸå®æ€§
- åæ£€æµ‹æŠ€æœ¯å¯ä»¥éšè—è‡ªåŠ¨åŒ–ç‰¹å¾
- éªŒè¯ç å¯¹æŠ—éœ€è¦ç»“åˆå›¾åƒå¤„ç†å’Œè½¨è¿¹æ¨¡æ‹Ÿ

## âš ï¸ æ³¨æ„äº‹é¡¹

- éµå®ˆç½‘ç«™æœåŠ¡æ¡æ¬¾ï¼Œä¸è¦ç”¨äºæ¶æ„ç›®çš„
- æŸäº›åçˆ¬æªæ–½æ˜¯åˆæ³•çš„ï¼Œå°Šé‡ç½‘ç«™çš„å®‰å…¨ç­–ç•¥
- CDP éœ€è¦ `debugger` æƒé™ï¼Œå¯èƒ½è¢«ç”¨æˆ·æ‹’ç»
- è¿‡åº¦è‡ªåŠ¨åŒ–å¯èƒ½è¢«æ£€æµ‹å’Œå°ç¦

## ğŸ”— æ‰©å±•é˜…è¯»

- [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/)
- [Puppeteer è‡ªåŠ¨åŒ–](https://pptr.dev/)
- [æµè§ˆå™¨æŒ‡çº¹è¯†åˆ«](https://browserleaks.com/)

