# 14. ä»£ç å®‰å…¨ä¸æ··æ·†

## ğŸ“š å­¦ä¹ ç›®æ ‡

- ç†è§£ä»£ç æ··æ·†çš„é‡è¦æ€§
- æŒæ¡æ ¸å¿ƒç®—æ³•çš„ WASM åŒ–
- å­¦ä¹ ä½¿ç”¨ä»£ç æ··æ·†å·¥å…·
- å®ç°ä»£ç åŠ å¯†å’Œä¿æŠ¤

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. ä»£ç å®‰å…¨å¨èƒ

æµè§ˆå™¨æ’ä»¶ä»£ç é¢ä¸´çš„å®‰å…¨å¨èƒï¼š

- **ä»£ç æš´éœ²**ï¼šæ‰€æœ‰ä»£ç éƒ½å¯ä»¥è¢«æŸ¥çœ‹å’Œå¤åˆ¶
- **ç®—æ³•çªƒå–**ï¼šæ ¸å¿ƒé€»è¾‘å®¹æ˜“è¢«é€†å‘
- **API å¯†é’¥æ³„éœ²**ï¼šç¡¬ç¼–ç çš„å¯†é’¥å¯èƒ½è¢«æå–
- **åŠŸèƒ½ç ´è§£**ï¼šä»˜è´¹åŠŸèƒ½å¯èƒ½è¢«ç»•è¿‡

### 2. ä»£ç æ··æ·†

#### ä½¿ç”¨ Terser æ··æ·†

```bash
npm install -D terser
```

```javascript
// vite.config.ts
import { defineConfig } from 'vite';
import { terser } from 'rollup-plugin-terser';

export default defineConfig({
  build: {
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // ç§»é™¤ console
        drop_debugger: true,
        pure_funcs: ['console.log'], // ç§»é™¤ç‰¹å®šå‡½æ•°
      },
      mangle: {
        toplevel: true, // æ··æ·†é¡¶å±‚å˜é‡
        properties: {
          regex: /^_/, // æ··æ·†ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„å±æ€§
        },
      },
      format: {
        comments: false, // ç§»é™¤æ³¨é‡Š
      },
    },
  },
});
```

#### ä½¿ç”¨ JavaScript Obfuscator

```bash
npm install -D javascript-obfuscator
```

```javascript
// vite.config.ts
import obfuscator from 'rollup-plugin-obfuscator';

export default defineConfig({
  plugins: [
    obfuscator({
      compact: true,
      controlFlowFlattening: true,
      controlFlowFlatteningThreshold: 0.75,
      deadCodeInjection: true,
      deadCodeInjectionThreshold: 0.4,
      debugProtection: false, // ç”Ÿäº§ç¯å¢ƒå¯å¼€å¯
      debugProtectionInterval: 0,
      disableConsoleOutput: true,
      identifierNamesGenerator: 'hexadecimal',
      log: false,
      numbersToExpressions: true,
      renameGlobals: false,
      selfDefending: true,
      simplify: true,
      splitStrings: true,
      splitStringsChunkLength: 10,
      stringArray: true,
      stringArrayCallsTransform: true,
      stringArrayEncoding: ['base64'],
      stringArrayIndexShift: true,
      stringArrayRotate: true,
      stringArrayShuffle: true,
      stringArrayWrappersCount: 2,
      stringArrayWrappersChainedCalls: true,
      stringArrayWrappersParametersMaxCount: 4,
      stringArrayWrappersType: 'function',
      stringArrayThreshold: 0.75,
      transformObjectKeys: true,
      unicodeEscapeSequence: false,
    }),
  ],
});
```

### 3. WASM åŒ–æ ¸å¿ƒç®—æ³•

#### ä½¿ç”¨ Rust ç¼–å†™æ ¸å¿ƒé€»è¾‘

```rust
// src/wasm/core/src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct CryptoEngine {
    key: Vec<u8>,
}

#[wasm_bindgen]
impl CryptoEngine {
    #[wasm_bindgen(constructor)]
    pub fn new(key: &[u8]) -> CryptoEngine {
        CryptoEngine {
            key: key.to_vec(),
        }
    }
    
    #[wasm_bindgen]
    pub fn encrypt(&self, data: &[u8]) -> Vec<u8> {
        // æ ¸å¿ƒåŠ å¯†ç®—æ³•ï¼ˆè¿™é‡Œæ˜¯ç¤ºä¾‹ï¼Œä½¿ç”¨ç®€å•çš„ XORï¼‰
        data.iter()
            .enumerate()
            .map(|(i, &byte)| byte ^ self.key[i % self.key.len()])
            .collect()
    }
    
    #[wasm_bindgen]
    pub fn decrypt(&self, data: &[u8]) -> Vec<u8> {
        // è§£å¯†ï¼ˆXOR æ˜¯å¯¹ç§°çš„ï¼‰
        self.encrypt(data)
    }
    
    #[wasm_bindgen]
    pub fn hash(&self, data: &[u8]) -> String {
        // å“ˆå¸Œç®—æ³•ï¼ˆç¤ºä¾‹ï¼‰
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(data);
        format!("{:x}", hasher.finalize())
    }
}
```

Cargo.toml:
```toml
[package]
name = "core"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
sha2 = "0.10"
```

ç¼–è¯‘ï¼š
```bash
wasm-pack build --target web --release
```

#### åœ¨æ’ä»¶ä¸­ä½¿ç”¨

```typescript
// src/shared/utils/crypto.ts
import init, { CryptoEngine } from '../../wasm/core/pkg/core';

let cryptoEngine: CryptoEngine | null = null;

async function initCrypto(key: Uint8Array) {
  await init();
  cryptoEngine = new CryptoEngine(key);
}

export async function encrypt(data: string, key: string): Promise<string> {
  if (!cryptoEngine) {
    await initCrypto(new TextEncoder().encode(key));
  }
  
  const dataBytes = new TextEncoder().encode(data);
  const encrypted = cryptoEngine!.encrypt(dataBytes);
  return btoa(String.fromCharCode(...encrypted)); // Base64 ç¼–ç 
}

export async function decrypt(encrypted: string, key: string): Promise<string> {
  if (!cryptoEngine) {
    await initCrypto(new TextEncoder().encode(key));
  }
  
  const encryptedBytes = Uint8Array.from(
    atob(encrypted).split('').map(c => c.charCodeAt(0))
  );
  const decrypted = cryptoEngine!.decrypt(encryptedBytes);
  return new TextDecoder().decode(decrypted);
}
```

### 4. ä»£ç åŠ å¯†

#### å­—ç¬¦ä¸²åŠ å¯†

```typescript
// src/shared/utils/stringEncrypt.ts
export class StringEncryptor {
  private static key = 'your-secret-key';
  
  // ç®€å•åŠ å¯†ï¼ˆXORï¼‰
  static encrypt(text: string): string {
    const key = this.key;
    let result = '';
    for (let i = 0; i < text.length; i++) {
      result += String.fromCharCode(
        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)
      );
    }
    return btoa(result); // Base64 ç¼–ç 
  }
  
  // è§£å¯†
  static decrypt(encrypted: string): string {
    const decoded = atob(encrypted);
    const key = this.key;
    let result = '';
    for (let i = 0; i < decoded.length; i++) {
      result += String.fromCharCode(
        decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length)
      );
    }
    return result;
  }
}

// ä½¿ç”¨å®æ›¿æ¢ï¼ˆæ„å»ºæ—¶ï¼‰
// åœ¨æ„å»ºè„šæœ¬ä¸­æ›¿æ¢æ‰€æœ‰ ENCRYPT('xxx') ä¸ºåŠ å¯†åçš„å­—ç¬¦ä¸²
```

#### æ„å»ºæ—¶åŠ å¯†å·¥å…·

```typescript
// scripts/encrypt-strings.ts
import * as fs from 'fs';
import * as path from 'path';

function encryptString(text: string): string {
  const key = 'your-secret-key';
  let result = '';
  for (let i = 0; i < text.length; i++) {
    result += String.fromCharCode(
      text.charCodeAt(i) ^ key.charCodeAt(i % key.length)
    );
  }
  return btoa(result);
}

function processFile(filePath: string) {
  let content = fs.readFileSync(filePath, 'utf-8');
  
  // åŒ¹é… ENCRYPT('xxx') æ¨¡å¼
  content = content.replace(
    /ENCRYPT\(['"]([^'"]+)['"]\)/g,
    (match, text) => {
      const encrypted = encryptString(text);
      return `StringEncryptor.decrypt('${encrypted}')`;
    }
  );
  
  fs.writeFileSync(filePath, content, 'utf-8');
}

// é€’å½’å¤„ç†æ‰€æœ‰æ–‡ä»¶
function processDirectory(dir: string) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      processDirectory(filePath);
    } else if (file.endsWith('.ts') || file.endsWith('.js')) {
      processFile(filePath);
    }
  });
}

processDirectory('./src');
```

### 5. API å¯†é’¥ä¿æŠ¤

#### åŠ¨æ€è·å–å¯†é’¥

```typescript
// src/background/apiKeyManager.ts
export class APIKeyManager {
  private static keys: Map<string, string> = new Map();
  
  // ä»æœåŠ¡å™¨è·å–å¯†é’¥ï¼ˆéœ€è¦ç”¨æˆ·ç™»å½•ï¼‰
  static async fetchKeys(userToken: string): Promise<void> {
    const response = await fetch('https://api.example.com/keys', {
      headers: {
        'Authorization': `Bearer ${userToken}`,
      },
    });
    
    const data = await response.json();
    this.keys.set('openai', data.openaiKey);
    this.keys.set('stripe', data.stripeKey);
  }
  
  // è·å–å¯†é’¥ï¼ˆå¦‚æœä¸å­˜åœ¨åˆ™ä»å­˜å‚¨åŠ è½½ï¼‰
  static async getKey(name: string): Promise<string | null> {
    if (this.keys.has(name)) {
      return this.keys.get(name)!;
    }
    
    // ä»åŠ å¯†å­˜å‚¨åŠ è½½
    const encrypted = await chrome.storage.local.get(`key_${name}`);
    if (encrypted[`key_${name}`]) {
      const decrypted = await decrypt(encrypted[`key_${name}`], this.getMasterKey());
      this.keys.set(name, decrypted);
      return decrypted;
    }
    
    return null;
  }
  
  private static getMasterKey(): string {
    // ä»ç¯å¢ƒå˜é‡æˆ–ç”¨æˆ·è¾“å…¥è·å–ä¸»å¯†é’¥
    // å¯ä»¥ç»“åˆè®¾å¤‡æŒ‡çº¹ç”Ÿæˆ
    return 'derived-from-device-fingerprint';
  }
  
  // ä¿å­˜å¯†é’¥ï¼ˆåŠ å¯†ï¼‰
  static async saveKey(name: string, key: string): Promise<void> {
    this.keys.set(name, key);
    const encrypted = await encrypt(key, this.getMasterKey());
    await chrome.storage.local.set({ [`key_${name}`]: encrypted });
  }
}
```

### 6. åŠŸèƒ½ä¿æŠ¤

#### License éªŒè¯

```typescript
// src/background/licenseManager.ts
import { CryptoEngine } from '../../wasm/core/pkg/core';

export class LicenseManager {
  private static licenseKey: string | null = null;
  
  static async validateLicense(key: string): Promise<boolean> {
    try {
      // è§£ç  License
      const decoded = this.decodeLicense(key);
      
      // éªŒè¯ç­¾å
      const valid = await this.verifySignature(decoded);
      if (!valid) return false;
      
      // æ£€æŸ¥è¿‡æœŸæ—¶é—´
      if (decoded.expiresAt < Date.now()) {
        return false;
      }
      
      // æ£€æŸ¥è®¾å¤‡ç»‘å®š
      const deviceId = await this.getDeviceId();
      if (decoded.deviceId && decoded.deviceId !== deviceId) {
        return false;
      }
      
      this.licenseKey = key;
      await chrome.storage.local.set({ licenseKey: key });
      return true;
    } catch (e) {
      return false;
    }
  }
  
  static async hasFeature(feature: string): Promise<boolean> {
    if (!this.licenseKey) {
      const stored = await chrome.storage.local.get('licenseKey');
      if (stored.licenseKey) {
        this.licenseKey = stored.licenseKey;
      } else {
        return false;
      }
    }
    
    const decoded = this.decodeLicense(this.licenseKey!);
    return decoded.features?.includes(feature) || false;
  }
  
  private static decodeLicense(key: string): {
    expiresAt: number;
    deviceId?: string;
    features?: string[];
  } {
    // è§£ç é€»è¾‘ï¼ˆBase64 + è§£å¯†ï¼‰
    const decoded = atob(key);
    // ... è§£å¯†å’Œè§£æ
    return JSON.parse(decoded);
  }
  
  private static async verifySignature(data: any): Promise<boolean> {
    // ä½¿ç”¨ WASM éªŒè¯ç­¾å
    // ...
    return true;
  }
  
  private static async getDeviceId(): Promise<string> {
    // ç”Ÿæˆè®¾å¤‡å”¯ä¸€ ID
    // ...
    return 'device-id';
  }
}
```

## ğŸ› ï¸ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1ï¼šæ„å»ºå®‰å…¨é…ç½®

åˆ›å»ºä¸€ä¸ª Vite æ’ä»¶ï¼Œåœ¨æ„å»ºæ—¶è‡ªåŠ¨æ··æ·†å’ŒåŠ å¯†ä»£ç ï¼š

```typescript
// vite-plugin-security.ts
import type { Plugin } from 'vite';
import JavaScriptObfuscator from 'javascript-obfuscator';

export function securityPlugin(options?: {
  obfuscate?: boolean;
  encryptStrings?: boolean;
}): Plugin {
  return {
    name: 'vite-plugin-security',
    generateBundle(options, bundle) {
      if (options.obfuscate) {
        Object.keys(bundle).forEach(fileName => {
          const chunk = bundle[fileName];
          if (chunk.type === 'chunk' && chunk.code) {
            const obfuscationResult = JavaScriptObfuscator.obfuscate(
              chunk.code,
              {
                compact: true,
                controlFlowFlattening: true,
                // ... å…¶ä»–é€‰é¡¹
              }
            );
            chunk.code = obfuscationResult.getObfuscatedCode();
          }
        });
      }
    },
  };
}
```

## ğŸ“ æ€»ç»“

- ä»£ç æ··æ·†å¯ä»¥å¢åŠ é€†å‘éš¾åº¦
- WASM åŒ–æ ¸å¿ƒç®—æ³•æä¾›æ›´å¥½çš„ä¿æŠ¤
- å­—ç¬¦ä¸²åŠ å¯†ä¿æŠ¤æ•æ„Ÿä¿¡æ¯
- API å¯†é’¥åº”è¯¥åŠ¨æ€è·å–å’ŒåŠ å¯†å­˜å‚¨
- License éªŒè¯ä¿æŠ¤ä»˜è´¹åŠŸèƒ½

## âš ï¸ æ³¨æ„äº‹é¡¹

- æ··æ·†ä¸æ˜¯ç»å¯¹å®‰å…¨ï¼Œåªæ˜¯å¢åŠ éš¾åº¦
- WASM æ–‡ä»¶ä»ç„¶å¯ä»¥è¢«åç¼–è¯‘ï¼ˆè™½ç„¶æ›´éš¾ï¼‰
- è¿‡åº¦æ··æ·†å¯èƒ½å½±å“æ€§èƒ½
- å®‰å…¨æ€§è¦ä¸ç”¨æˆ·ä½“éªŒå¹³è¡¡

## ğŸ”— æ‰©å±•é˜…è¯»

- [JavaScript Obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator)
- [Terser](https://github.com/terser/terser)
- [WebAssembly å®‰å…¨](https://webassembly.org/docs/security/)

