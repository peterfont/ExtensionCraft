# 13. èº«ä»½ä¼ªè£…ï¼šæµè§ˆå™¨æŒ‡çº¹å¯¹æŠ—

## ğŸ“š å­¦ä¹ ç›®æ ‡

- ç†è§£æµè§ˆå™¨æŒ‡çº¹è¯†åˆ«æŠ€æœ¯
- æŒæ¡ Canvas/WebGL æŒ‡çº¹å¯¹æŠ—
- å­¦ä¹ ä¿®æ”¹ navigator å±æ€§
- å®ç°è‡ªåŠ¨åŒ–å·¥å…·æ£€æµ‹ç»•è¿‡

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. æµè§ˆå™¨æŒ‡çº¹æ¦‚è¿°

æµè§ˆå™¨æŒ‡çº¹æ˜¯é€šè¿‡æ”¶é›†æµè§ˆå™¨å’Œè®¾å¤‡çš„å„ç§ç‰¹å¾æ¥å”¯ä¸€è¯†åˆ«ç”¨æˆ·çš„æŠ€æœ¯ï¼š

#### å¸¸è§æŒ‡çº¹æ¥æº

1. **User-Agent**ï¼šæµè§ˆå™¨ç‰ˆæœ¬ã€æ“ä½œç³»ç»Ÿ
2. **Canvas æŒ‡çº¹**ï¼šå­—ä½“æ¸²æŸ“å·®å¼‚
3. **WebGL æŒ‡çº¹**ï¼šGPU ä¿¡æ¯
4. **AudioContext æŒ‡çº¹**ï¼šéŸ³é¢‘å¤„ç†å·®å¼‚
5. **Screen ä¿¡æ¯**ï¼šåˆ†è¾¨ç‡ã€é¢œè‰²æ·±åº¦
6. **æ—¶åŒº**ï¼šUTC åç§»
7. **è¯­è¨€**ï¼šnavigator.languages
8. **æ’ä»¶**ï¼šnavigator.plugins
9. **å­—ä½“**ï¼šå¯ç”¨å­—ä½“åˆ—è¡¨

### 2. Canvas æŒ‡çº¹å¯¹æŠ—

#### é—®é¢˜ï¼šCanvas æŒ‡çº¹è¯†åˆ«

```javascript
// ç½‘ç«™çš„æ£€æµ‹ä»£ç 
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
ctx.textBaseline = 'top';
ctx.font = '14px Arial';
ctx.fillText('æŒ‡çº¹æµ‹è¯•', 2, 2);
const fingerprint = canvas.toDataURL(); // åŸºäºå­—ä½“æ¸²æŸ“å·®å¼‚
```

#### è§£å†³æ–¹æ¡ˆï¼šCanvas å™ªéŸ³æ³¨å…¥

```typescript
// src/content/inject/canvasFingerprint.ts
export class CanvasFingerprintSpoof {
  private noiseLevel = 0.0001; // å™ªéŸ³çº§åˆ«ï¼ˆ0-1ï¼‰
  
  install() {
    this.hookCanvasToDataURL();
    this.hookCanvasToBlob();
    this.hookGetImageData();
  }
  
  private hookCanvasToDataURL() {
    const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
    
    HTMLCanvasElement.prototype.toDataURL = function(
      type?: string,
      quality?: number
    ): string {
      const imageData = this.getContext('2d')?.getImageData(
        0, 0, this.width, this.height
      );
      
      if (imageData) {
        this.addNoise(imageData);
        this.getContext('2d')?.putImageData(imageData, 0, 0);
      }
      
      return originalToDataURL.apply(this, [type, quality]);
    };
  }
  
  private hookCanvasToBlob() {
    const originalToBlob = HTMLCanvasElement.prototype.toBlob;
    
    HTMLCanvasElement.prototype.toBlob = function(
      callback: BlobCallback | null,
      type?: string,
      quality?: number
    ): void {
      const imageData = this.getContext('2d')?.getImageData(
        0, 0, this.width, this.height
      );
      
      if (imageData) {
        this.addNoise(imageData);
        this.getContext('2d')?.putImageData(imageData, 0, 0);
      }
      
      return originalToBlob.apply(this, [callback, type, quality]);
    };
  }
  
  private hookGetImageData() {
    const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
    
    CanvasRenderingContext2D.prototype.getImageData = function(
      sx: number,
      sy: number,
      sw: number,
      sh: number
    ): ImageData {
      const imageData = originalGetImageData.apply(this, [sx, sy, sw, sh]);
      this.addNoise(imageData);
      return imageData;
    };
  }
  
  private addNoise(imageData: ImageData) {
    const data = imageData.data;
    const noise = this.noiseLevel * 255;
    
    for (let i = 0; i < data.length; i += 4) {
      // åªå¯¹ RGB æ·»åŠ å™ªéŸ³ï¼Œä¸å½±å“ Alpha
      if (Math.random() < 0.1) { // 10% çš„åƒç´ æ·»åŠ å™ªéŸ³
        data[i] += (Math.random() - 0.5) * noise;     // R
        data[i + 1] += (Math.random() - 0.5) * noise; // G
        data[i + 2] += (Math.random() - 0.5) * noise; // B
      }
    }
  }
  
  setNoiseLevel(level: number) {
    this.noiseLevel = Math.max(0, Math.min(1, level));
  }
}

// ä½¿ç”¨
const canvasSpoof = new CanvasFingerprintSpoof();
canvasSpoof.install();
```

### 3. WebGL æŒ‡çº¹å¯¹æŠ—

```typescript
// src/content/inject/webglFingerprint.ts
export class WebGLFingerprintSpoof {
  install() {
    this.hookGetParameter();
    this.hookGetExtension();
    this.hookGetSupportedExtensions();
  }
  
  private hookGetParameter() {
    const originalGetParameter = WebGLRenderingContext.prototype.getParameter;
    
    WebGLRenderingContext.prototype.getParameter = function(parameter: number): any {
      // ä¿®æ”¹å…³é”®å‚æ•°
      if (parameter === this.VENDOR) {
        return 'Intel Inc.';
      }
      if (parameter === this.RENDERER) {
        return 'Intel Iris OpenGL Engine';
      }
      if (parameter === this.SHADING_LANGUAGE_VERSION) {
        return 'WebGL GLSL ES 1.0';
      }
      if (parameter === this.VERSION) {
        return 'WebGL 1.0';
      }
      
      return originalGetParameter.apply(this, [parameter]);
    };
    
    // WebGL2
    if (typeof WebGL2RenderingContext !== 'undefined') {
      const originalGetParameter2 = WebGL2RenderingContext.prototype.getParameter;
      WebGL2RenderingContext.prototype.getParameter = function(parameter: number): any {
        if (parameter === this.VENDOR) {
          return 'Intel Inc.';
        }
        if (parameter === this.RENDERER) {
          return 'Intel Iris OpenGL Engine';
        }
        return originalGetParameter2.apply(this, [parameter]);
      };
    }
  }
  
  private hookGetExtension() {
    const originalGetExtension = WebGLRenderingContext.prototype.getExtension;
    
    WebGLRenderingContext.prototype.getExtension = function(name: string): any {
      // è¿”å›æ ‡å‡†æ‰©å±•ï¼Œéšè—ç‰¹æ®Šæ‰©å±•
      const result = originalGetExtension.apply(this, [name]);
      
      // å¯ä»¥åœ¨è¿™é‡Œä¿®æ”¹æ‰©å±•ä¿¡æ¯
      return result;
    };
  }
  
  private hookGetSupportedExtensions() {
    const originalGetSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
    
    WebGLRenderingContext.prototype.getSupportedExtensions = function(): string[] | null {
      const extensions = originalGetSupportedExtensions.apply(this);
      
      // è¿”å›æ ‡å‡†æ‰©å±•åˆ—è¡¨
      return extensions?.filter(ext => 
        !ext.includes('experimental') && 
        !ext.includes('WEBKIT')
      ) || null;
    };
  }
}
```

### 4. Navigator å±æ€§ä¿®æ”¹

```typescript
// src/content/inject/navigatorSpoof.ts
export class NavigatorSpoof {
  install(config?: {
    userAgent?: string;
    platform?: string;
    languages?: string[];
    hardwareConcurrency?: number;
    deviceMemory?: number;
  }) {
    const defaultConfig = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      languages: navigator.languages,
      hardwareConcurrency: navigator.hardwareConcurrency,
      deviceMemory: (navigator as any).deviceMemory || 8,
      ...config,
    };
    
    // ä¿®æ”¹ userAgent
    Object.defineProperty(navigator, 'userAgent', {
      get: () => defaultConfig.userAgent,
      configurable: true,
    });
    
    // ä¿®æ”¹ platform
    Object.defineProperty(navigator, 'platform', {
      get: () => defaultConfig.platform,
      configurable: true,
    });
    
    // ä¿®æ”¹ languages
    Object.defineProperty(navigator, 'languages', {
      get: () => defaultConfig.languages,
      configurable: true,
    });
    
    // ä¿®æ”¹ hardwareConcurrency
    Object.defineProperty(navigator, 'hardwareConcurrency', {
      get: () => defaultConfig.hardwareConcurrency,
      configurable: true,
    });
    
    // ä¿®æ”¹ deviceMemory
    Object.defineProperty(navigator, 'deviceMemory', {
      get: () => defaultConfig.deviceMemory,
      configurable: true,
    });
    
    // éšè— webdriver
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
      configurable: true,
    });
    
    // ä¿®æ”¹ plugins
    this.spoofPlugins();
    
    // ä¿®æ”¹ permissions
    this.spoofPermissions();
  }
  
  private spoofPlugins() {
    const fakePlugins = [
      {
        0: { type: 'application/x-google-chrome-pdf', suffixes: 'pdf', description: 'Portable Document Format' },
        description: 'Portable Document Format',
        filename: 'internal-pdf-viewer',
        length: 1,
        name: 'Chrome PDF Plugin',
      },
      {
        0: { type: 'application/pdf', suffixes: 'pdf', description: '' },
        description: '',
        filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
        length: 1,
        name: 'Chrome PDF Viewer',
      },
    ];
    
    Object.defineProperty(navigator, 'plugins', {
      get: () => fakePlugins as any,
      configurable: true,
    });
  }
  
  private spoofPermissions() {
    const originalQuery = navigator.permissions.query;
    navigator.permissions.query = (parameters: PermissionDescriptor) => {
      // è¿”å›æ ‡å‡†æƒé™çŠ¶æ€
      if (parameters.name === 'notifications') {
        return Promise.resolve({
          state: Notification.permission as PermissionState,
          onchange: null,
        });
      }
      return originalQuery.call(navigator.permissions, parameters);
    };
  }
}
```

### 5. AudioContext æŒ‡çº¹å¯¹æŠ—

```typescript
// src/content/inject/audioFingerprint.ts
export class AudioFingerprintSpoof {
  install() {
    this.hookAudioContext();
  }
  
  private hookAudioContext() {
    const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
    if (!AudioContext) return;
    
    const originalCreateAnalyser = AudioContext.prototype.createAnalyser;
    AudioContext.prototype.createAnalyser = function() {
      const analyser = originalCreateAnalyser.apply(this);
      
      // Hook getFloatFrequencyData
      const originalGetFloatFrequencyData = analyser.getFloatFrequencyData;
      analyser.getFloatFrequencyData = function(array: Float32Array) {
        originalGetFloatFrequencyData.apply(this, [array]);
        
        // æ·»åŠ å¾®å°çš„éšæœºå™ªéŸ³
        for (let i = 0; i < array.length; i++) {
          array[i] += (Math.random() - 0.5) * 0.0001;
        }
      };
      
      return analyser;
    };
  }
}
```

### 6. å®Œæ•´çš„æŒ‡çº¹å¯¹æŠ—ç³»ç»Ÿ

```typescript
// src/content/inject/stealthMode.ts
import { CanvasFingerprintSpoof } from './canvasFingerprint';
import { WebGLFingerprintSpoof } from './webglFingerprint';
import { NavigatorSpoof } from './navigatorSpoof';
import { AudioFingerprintSpoof } from './audioFingerprint';

export class StealthMode {
  private canvasSpoof: CanvasFingerprintSpoof;
  private webglSpoof: WebGLFingerprintSpoof;
  private navigatorSpoof: NavigatorSpoof;
  private audioSpoof: AudioFingerprintSpoof;
  
  constructor() {
    this.canvasSpoof = new CanvasFingerprintSpoof();
    this.webglSpoof = new WebGLFingerprintSpoof();
    this.navigatorSpoof = new NavigatorSpoof();
    this.audioSpoof = new AudioFingerprintSpoof();
  }
  
  enable(config?: {
    canvasNoise?: number;
    userAgent?: string;
    languages?: string[];
  }) {
    // å®‰è£…æ‰€æœ‰å¯¹æŠ—æ¨¡å—
    this.canvasSpoof.setNoiseLevel(config?.canvasNoise || 0.0001);
    this.canvasSpoof.install();
    
    this.webglSpoof.install();
    
    this.navigatorSpoof.install({
      userAgent: config?.userAgent,
      languages: config?.languages,
    });
    
    this.audioSpoof.install();
    
    // å…¶ä»–å¯¹æŠ—æªæ–½
    this.hideWebDriver();
    this.spoofChromeObject();
    this.spoofScreen();
  }
  
  private hideWebDriver() {
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
      configurable: true,
    });
    
    // åˆ é™¤ webdriver ç›¸å…³å±æ€§
    delete (window as any).navigator.__proto__.webdriver;
  }
  
  private spoofChromeObject() {
    if (!(window as any).chrome) {
      (window as any).chrome = {};
    }
    
    if (!(window as any).chrome.runtime) {
      (window as any).chrome.runtime = {};
    }
  }
  
  private spoofScreen() {
    Object.defineProperty(screen, 'availWidth', {
      get: () => 1920,
      configurable: true,
    });
    
    Object.defineProperty(screen, 'availHeight', {
      get: () => 1080,
      configurable: true,
    });
    
    Object.defineProperty(screen, 'width', {
      get: () => 1920,
      configurable: true,
    });
    
    Object.defineProperty(screen, 'height', {
      get: () => 1080,
      configurable: true,
    });
    
    Object.defineProperty(screen, 'colorDepth', {
      get: () => 24,
      configurable: true,
    });
    
    Object.defineProperty(screen, 'pixelDepth', {
      get: () => 24,
      configurable: true,
    });
  }
}

// ä½¿ç”¨
const stealth = new StealthMode();
stealth.enable({
  canvasNoise: 0.0001,
  userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
  languages: ['zh-CN', 'zh', 'en'],
});
```

## ğŸ› ï¸ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1ï¼šæŒ‡çº¹æ£€æµ‹å·¥å…·

åˆ›å»ºä¸€ä¸ªå·¥å…·æ¥æ£€æµ‹å½“å‰æµè§ˆå™¨çš„æŒ‡çº¹ç‰¹å¾ï¼š

```typescript
// src/content/utils/fingerprintDetector.ts
export class FingerprintDetector {
  async detect(): Promise<{
    canvas: string;
    webgl: any;
    audio: number;
    screen: any;
    navigator: any;
  }> {
    return {
      canvas: await this.detectCanvas(),
      webgl: await this.detectWebGL(),
      audio: await this.detectAudio(),
      screen: this.detectScreen(),
      navigator: this.detectNavigator(),
    };
  }
  
  private async detectCanvas(): Promise<string> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('æŒ‡çº¹æµ‹è¯• ğŸ”', 2, 2);
    return canvas.toDataURL();
  }
  
  private async detectWebGL(): Promise<any> {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return null;
    
    return {
      vendor: gl.getParameter(gl.VENDOR),
      renderer: gl.getParameter(gl.RENDERER),
      version: gl.getParameter(gl.VERSION),
      shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
    };
  }
  
  private async detectAudio(): Promise<number> {
    const context = new (window.AudioContext || (window as any).webkitAudioContext)();
    const oscillator = context.createOscillator();
    const analyser = context.createAnalyser();
    const gainNode = context.createGain();
    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
    
    gainNode.gain.value = 0;
    oscillator.connect(analyser);
    analyser.connect(scriptProcessor);
    scriptProcessor.connect(gainNode);
    gainNode.connect(context.destination);
    
    oscillator.start(0);
    
    return new Promise((resolve) => {
      scriptProcessor.onaudioprocess = (event) => {
        const output = event.inputBuffer.getChannelData(0);
        let sum = 0;
        for (let i = 0; i < output.length; i++) {
          sum += Math.abs(output[i]);
        }
        const average = sum / output.length;
        resolve(average);
      };
    });
  }
  
  private detectScreen(): any {
    return {
      width: screen.width,
      height: screen.height,
      availWidth: screen.availWidth,
      availHeight: screen.availHeight,
      colorDepth: screen.colorDepth,
      pixelDepth: screen.pixelDepth,
    };
  }
  
  private detectNavigator(): any {
    return {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      languages: navigator.languages,
      hardwareConcurrency: navigator.hardwareConcurrency,
      deviceMemory: (navigator as any).deviceMemory,
      webdriver: (navigator as any).webdriver,
    };
  }
}
```

## ğŸ“ æ€»ç»“

- æµè§ˆå™¨æŒ‡çº¹é€šè¿‡å¤šç§ç‰¹å¾è¯†åˆ«ç”¨æˆ·
- Canvas/WebGL/Audio æŒ‡çº¹å¯ä»¥é€šè¿‡å™ªéŸ³æ³¨å…¥å¯¹æŠ—
- Navigator å±æ€§å¯ä»¥é€šè¿‡ defineProperty ä¿®æ”¹
- å®Œæ•´çš„å¯¹æŠ—ç³»ç»Ÿéœ€è¦ç»¼åˆå¤šç§æŠ€æœ¯
- å¯¹æŠ—æŒ‡çº¹è¦å¹³è¡¡æ•ˆæœå’Œæ€§èƒ½

## âš ï¸ æ³¨æ„äº‹é¡¹

- æŸäº›å¯¹æŠ—æŠ€æœ¯å¯èƒ½å½±å“ç½‘ç«™åŠŸèƒ½
- è¿‡åº¦å¯¹æŠ—å¯èƒ½è¢«æ£€æµ‹ä¸ºå¼‚å¸¸
- è¦éµå®ˆæ³•å¾‹æ³•è§„ï¼Œä¸è¦ç”¨äºéæ³•ç›®çš„
- æŒ‡çº¹å¯¹æŠ—æ˜¯æŒç»­çš„æŠ€æœ¯å¯¹æŠ—è¿‡ç¨‹

## ğŸ”— æ‰©å±•é˜…è¯»

- [æµè§ˆå™¨æŒ‡çº¹è¯†åˆ«](https://browserleaks.com/)
- [AmIUnique](https://amiunique.org/)
- [Canvas æŒ‡çº¹åŸç†](https://browserleaks.com/canvas)

